/*
1. Написать функцию, преобразующую число в объект. Передавая на вход число от 0 до 999, мы
должны получить на выходе объект, в котором в соответствующих свойствах описаны
единицы, десятки и сотни. Например, для числа 245 мы должны получить следующий объект:
{‘единицы’: 5, ‘десятки’: 4, ‘сотни’: 2}. Если число превышает 999, необходимо выдать
соответствующее сообщение с помощью console.log и вернуть пустой объект.
*/

const numToObj = (num) =>{
	// объявляем объект, содержащий нужные свойства и присваиваем им значения:
	let finalObj = {};
	// парсим на входе число до круглого и проверяем, что оно совпадает с увловием от 0 до 999: 
	if(parseInt(num) >= 0 && parseInt(num) < 1000){
		// считаем количество символов в числе:
		const x = num.toString().length;
		// переводим число в строку, чтобы можно было обращаться к её индексам:
		const stringNum = num.toString();
		// дальше, в зависимости от длины числа, передаем соответствующим свойствам их значения:
		if(x === 0){
		} else if (x === 1){
			finalObj['единицы'] = stringNum[0];
		} else if (x === 2){
			finalObj['десятки'] = stringNum[0];
			finalObj['единицы'] = stringNum[1];
		} else if (x === 3){
			finalObj['сотни'] = stringNum[0]; 
			finalObj['десятки'] = stringNum[1];
			finalObj['единицы'] = stringNum[2];
		}
	} else {
		console.log('Error: not >= 0 and < 1000 number!');
		return finalObj;
	};
	// возвращаем финальный объект:
	return finalObj;
};
// обращаемся к функции и выводим результат в консоль:
console.log(numToObj(976));

/* 2. Начиная с этого урока, мы начинаем работать с функционалом интернет-магазина.
Предположим, что у нас есть сущность корзины. Нужно реализовать функционал подсчета
стоимости корзины в зависимости от находящихся в ней товаров. Товары в корзине хранятся в
массиве.
2.1. Организуйте такой массив для хранения товаров в корзине
2.2. Организуйте функцию countBasketPrice, которая будет считать стоимость корзины. */

let basketItems = ['Утюг', 'Утюг', 'Кофеварка','Пылесос'];
let ItemsCost = [['Утюг', 100], ['Кофеварка', 50],['Пылесос', 250]];

//функция возврата стоимости конкретного товара.
const getItemPrice = (item, array) =>{
	let items = [];
	let costs = [];
	//предполагаем, что мы знаем структуру массива со стоимостями товара, поэтому разбиваем его на 2 одномерных массива
	for(let i=0; i<array.length; i++){
		items.push(array[i][0]);
		costs.push(array[i][1]);
	}
	//используя метод .indexOf получаем индекс товара в массиве с названиями товаров и возвращаем стоимость по этому индексу из массива цен
	return costs[items.indexOf(item)];
}

const countBasketPrice = (basketArr, costArr) =>{
	let totalCost = 0;
	for(let i=0;i<basketArr.length;i++){
		//на каждой итерации обхода массива корзины обращаемся к функции получения стоимости единицы товара.
		totalCost += getItemPrice(basketArr[i],costArr);
	}
	return totalCost;
}
console.log("Массив корзины: "+basketItems);
console.log("Массив стоимости каждого товара: "+ItemsCost);
console.log("Вывод полной стоимости корзины: "+countBasketPrice(basketItems, ItemsCost));

/*
2. Продолжаем работу с нашим интернет-магазином
2.1. В прошлом ДЗ Вы реализовали корзину на базе массивов. Какими объектами можно
заменить элементы данных массивов?
2.2. Реализуйте такие объекты
2.3. Перенесите функционал подсчета корзины на объектно-ориентированную базу
*/

let itemsDatabaseObj = {
	// перечень товаров в категории Items
	_items: {
		'Утюг':{
			cost: 100,
			id: 7763626,
			fullName: 'Samsung G433'
		},
		'Кофеварка':{
			cost: 50,
			id: 7763624
		},
		'Пылесос':{
			cost: 250,
			id: 7763625
		}
	}, 
	// ссылка на items:
	get items(){
		return this._items;
	},
	// функция добавления продукта:
	addItem(name, cost, id, fullName){
		let newItem = {
			cost,
			id,
			fullName
		};
		this.items[name] = newItem;
	},
	// функция удаления продукта:
	removeItem(name){
		delete this.items[name];
	},
	// функция возврата стоимости товара по названию товара:
	getItemCost(name){
		return this.items[name].cost;
	},
	// функция возврата полной стоимости корзины с учетом количества каждого элемента:
	getItemCostAll(obj){
		let totalCost = 0;
		// получаем перечень ключей корзины
		let keysObj = Object.keys(obj);
		for (let i=0; i<keysObj.length;i++){
			/*console.log(keysObj[i]+' costs: '+this.getItemCost(keysObj[i])+' times: '+obj[keysObj[i]].count);*/
			totalCost += this.getItemCost(keysObj[i]) * obj[keysObj[i]].count;
				/* ... this.getItemCost(keysObj[i]) - передаем название продукта из массива ключей в функцию воврата стоимости товара getItemCost,
					... * obj[keysObj[i]].count - перемножаем на значение количества продуктов в объекте корзины,
						totalCost += ...- то что получилось, добавляем в общую стоимость.
				*/
		}
		// возвращаем общую стоимость:
		return totalCost;
	},
};
/*itemsDatabaseObj.addItem('Грелка', 50, 67788, 'Грелка бытовая');
console.log(itemsDatabaseObj.items);
itemsDatabaseObj.removeItem('Грелка');
console.log(itemsDatabaseObj.items);*/

// корзина с товарами и количеством каждого товара:
let basketItemsObj = {
	'Утюг':{
		count: 2
	},
	'Кофеварка':{
		count: 3
	},
	'Пылесос':{
		count: 1
	}
};

// вывод метода getItemCostAll объекта itemsDatabaseObj в консоль:
console.log(itemsDatabaseObj.getItemCostAll(basketItemsObj));

/*
3. * Подумайте над глобальными сущностями. К примеру, сущность “Продукт” в
интернет-магазине актуальна не только для корзины, но и для каталога. Стремиться нужно к
тому, чтобы объект “Продукт” имел единую структуру для различных модулей нашего сайта,
но в разных местах давал возможность вызывать разные методы.
*/

// по сути, itemsDatabaseObj - это и есть глобальная сущность "продукт", она содержит в себе информацию о продуктах и методы работы с ними.